This section will introduce and develop the \rrtfunnel{} algorithm, by two
means: First develop robust motion primitives through the \ac{SOS} programming
framework based on the work by \cite{majumdarFunnelLibrariesRealtime2017}, and
second, deploy these funnels as robust motion primitives in a discrete \ac{RRT}
robust motion planner based on \cite{Lav06}. Using robust motion primitives has
several advantages. Firstly, they handle uncertainty, and thus, as long as the
uncertainties in the system are akin to the assumptions on the incoming
uncertainty parameters, the dynamical system will not leave the funnel, and
hence if the funnel is not in collision, neither will the system be. Secondly,
as the motion primitives are robust, there is no need for more conservative
maneuvers and heuristics, such as maximizing the distance to an obstacle, which
is a naive way for motion planners to handle uncertainty. Since the primitives
are robust, the system might as well choose a primitive that is close to an
obstacle, as one that is far away, since the funnel is guaranteed to be
collision-free in both cases. This means that a robust motion algorithm can
perform more aggressive maneuvers than one that is inherently conservative about
its environment and maneuvers~\cite{singhRobustOnlineMotion2017}.


\subsection{Generating Robust Motion Primitives}
\label{sec:generating-robust-motion-primitives}

In order to create a basic set of funnels as the robust motion primitives for
the \rrtfunnel{} motion planning algorithm, a few obstacles has to be overcome.
The first one is settling on a dynamical system model for the funnel
calculations. This paper employs the simple unicycle model from
\author{Lav06}~\cite[613]{Lav06} which is modified slightly into
\begin{equation}
  \label{eq:model-dynamics}
  \vect{x} =
  \begin{bmatrix}
    x \\ y \\ \theta \\
  \end{bmatrix}, \, \dot{\vect{x}} =
  \begin{bmatrix}
    -v \sin(\theta) \\
    v \cos(\theta) \\
    u \\
  \end{bmatrix}
  ,
\end{equation}
which is a first-order unicycle model with constant speed of
\(v=10\) \IEEEunit{m/s}. A picture of the model can be found in
\cref{fig:second-order-unicycle}.
\begin{figure}[!t]
  \centering
  \def\svgwidth{.5\columnwidth}
  \import{figures/method/}{unicycle-model.pdf_tex}
  \caption{The unicycle model of an airplane.}
  \label{fig:second-order-unicycle}
\end{figure}
Although this is the only model used in this paper, the framework and the code
is easily adapted into accommodating a different and more complicated model.


\subsubsection{Generating Trajectories}
\label{subsec:generating-the-trajectories}

The robust motion primitives are \textit{finite regions of time variance} around
an initial trajectory, meaning that they are all the states surrounding a
trajectory in which the system can reach in a given time. But in order to verify
the robust regions surrounding a trajectory, first the trajectories themselves
have to be generated. Generating optimal trajectories is a rich field in the
motion planning literature~\cite{Betts_1998}. The initial trajectories can be
generated by many different methods, however the \textit{direct collocation
  method} suited the needs of this paper best~\cite{von1993numerical}. It was
chosen as it builds locally optimal trajectories from a discrete set of sampled
points along a sought trajectory, which is beneficial for the discrete funnel
verification in \cref{subsec:generating-funnels}. All optimal trajectory
generators need a cost function to optimize. For this problem the cost function
chosen for the solver to minimize is:
\begin{equation}
  J = \int_{0}^{T} \left[ 1 + {\vect{u}_{0}}^{T} \matr{R} \vect{u}_{0} \right] \mathrm{d}t,
\end{equation}
where \(\matr{R} = 1\), because it will minimize the system input, and thus give
a smooth output trajectory~\cite{majumdarRobustOnlineMotion2013}.

An example of an initial trajectory set generated with the direct collocation
method, and the given cost function is pictured
in~\cref{fig:initial-trajectories}, and consists of a left-turn, a
straight-forward, and a right-turn trajector.

\begin{figure}[!t]
  \begin{minipage}[t]{0.3\linewidth}
    \includegraphics[trim={5cm 5cm 5cm 5cm},
    width=.85\linewidth]{figures/method/left-trajector}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.3\linewidth}
    \includegraphics[trim={5cm 5cm 5cm 5cm},
    width=.85\linewidth]{figures/method/straight-trajector}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.3\linewidth}
    \includegraphics[trim={5cm 5cm 5cm 5cm},
    width=.85\linewidth]{figures/method/right-trajector}
  \end{minipage}
  \caption[Three motion primitives for the \rrtfunnel{} algorithm]{Three motion primitives for the \rrtfunnel{} algorithm, one straight,
    one left, and one right turn.}
  \label{fig:initial-trajectories}
\end{figure}


\subsubsection{Initializing the Funnel Calculations}
\label{subsec:initializing-tvlqr}

The funnel calculation algorithm has to be initialized with a candidate Lyapunov
function. In the same way as in
\citeauthor{majumdarRobustOnlineMotion2013}~\cite{majumdarRobustOnlineMotion2013},
the funnel generation algorithm will be initialized with a \ac{TV-LQR}
controller as the initial Lyapunov function employing a cost function of the
form
\begin{IEEEeqnarray*}{ll}
  J &= \vect{x}^{T} (t_f) \matr{F}(t_f) \vect{x} (t_f) \IEEEyesnumber \\
    &+ \int_{t_{0}}^{t_{f}} \left( \vect{x}^{T} \matr{Q} \vect{x} + \vect{u}^{T} \matr{R} \vect{u} + 2 \vect{x}^T \matr{N} \vect{u} \right) \mathrm{d}t,
\end{IEEEeqnarray*}
which when employed on the linearization of the system error
dynamics~\eqref{eq:system-error-dynamics} gives
\begin{equation}
  \dot{\bar{\vect{x}}} \approx \matr{A} (t)\bar{\vect{x}}(t) + \matr{B}(t) \bar{\vect{u}}(t)
\end{equation}
\begin{equation}
  \dot{\bar{\vect{x}}} \approx %
  \begin{bmatrix}
    0 & 0 & -v\cos(\theta) \\
    0 & 0 & -v\sin(\theta) \\
    0 & 0 & 0 \\
  \end{bmatrix} %
  \bar{\vect{x}} (t) %
  + %
  \begin{bmatrix}
    0 \\ 0 \\ 1
  \end{bmatrix} %
  \bar{\vect{u}}(t),
\end{equation} 
which is an an initial candidate Lyapunov function of the form
\begin{equation}
  V(t,\bar{\vect{x}}) = {\bar{\vect{x}}}^{T} \matr{S}_{i}\bar{\vect{x}} ,
\end{equation}
where \(S_{i}\) is a solution of the \textit{Ricatti} equation
\begin{IEEEeqnarray*}{Cr}
  \label{eq:ricatti}
  - \dot{\matr{S}}(t) = \matr{A}^{T} \matr{S}(t) +\matr{S}(t) \matr{A} - \left( \matr{S}(t) \matr{B} + \matr{N} \right) \matr{R}^{-1} \IEEEyesnumber \\
  \IEEEeqnarraymulticol{2}{r}{\left( \matr{B}^{T} \matr{S}(t) + \matr{N}^{T} \right) + \matr{Q}}
\end{IEEEeqnarray*} 
associated with the \ac{LQR} controller. The feedback is gained from
\[
  \matr{K}(t) = \matr{R}^{-1} \left( \matr{B} \matr{S}(t) + \matr{N}^T \right),
\]
and enables the system dynamics \cref{eq:model-dynamics} to be written
\(f_{\mathit{cl}}(t,\vect{x})\) by direct substitution of \(\vect{u} =
-K\vect{x}\), and hence making the system \cref{eq:model-dynamics} only
dependent on \(t\) and \(\vect{x}\),
\begin{equation}
  \label{eq:model-dynamics-cl}
  \vect{x} =
  \begin{bmatrix}
    x \\ y \\ \theta \\
  \end{bmatrix}, \, \dot{\vect{x}} =
  \begin{bmatrix}
    -v \sin(\theta) \\
    v \cos(\theta) \\
    -K\vect{x} \\
  \end{bmatrix} \mathEoS
\end{equation}


\subsection{Generating Funnels Around Trajectories}
\label{subsec:generating-funnels}

With the nominal trajectories, and the initial Lyapunov functions ready, the
funnels around the nominal trajectories can be calculated using
\cref{alg:funnelalgorithm} on page~\pageref{alg:funnelalgorithm}, and is
implemented in software through the \textsc{sostools}~\cite{sostools} toolbox as
shown in \cref{sec:sos-program-implementation}.

However, the dynamics for the model in \cref{eq:model-dynamics-cl} are still not
polynomial, given the \(\sin\) and \(\cos\) terms
in~\eqref{eq:model-dynamics-cl}, and the \ac{SOS}-framework can only verify
polynomial systems. Thus in order to obtain the needed polynomial dynamics, the
system is expanded around the nominal trajectory with a Taylor expansion of
degree three. The function limiting the size of the funnel \(\rho(t_{k})\) also
has to be initialized by a feasible upper bound \(\rho(t)\). This is done
through the equation
\begin{equation}
  \rho(t_{k}) = \mathrm{exp}\left( \rho_{\tau}\frac{\left( t_{f} - t \right)}{\left( t_{f} - t_{0}  \right)}\right) + \rho_0
\end{equation}
where \(\rho_{\tau}\) is a positive constant determining the upper bound on the
funnel, along with the zero value \(\rho_0\)~\cite{Tobenkin_2011}. If the given
choice of \(\rho_{\tau}\) does not verify a funnel, either increase the value of
\(\rho_{\tau}\) and \(\rho_0\), and optionally the number of sampled points from
the trajectory to be verified~\cite{Tobenkin_2011}.

The initial condition set also has to be decided before the reachable set can be
calculated. In general the initial condition set can be any semi-algebraic set
in the state-space. However, a simple way of obtaining an initial condition set
for the trajectories at hand is by taking advantage of the Lyapunov function
candidate from the \ac{LQR}-controller. Thus by setting
\begin{equation}
  \mathcal{X}_{0} = \frac{ \matr{S}_{k}}{\rho_{\tau}},
\end{equation}
an initial condition set is obtained. In general however, any semi-algebraic set
will do, and the algorithm is not constrained to this one initial condition set
in particular, but it has proven itself useful when calculating new motion
primitives for a system when the initial condition set is not obvious. Another
idea is to use the outlet of one funnel as the initial condition set for the
calculation of the next.

The funnels in this thesis are parameterized as sub-level sets of a Lyapunov
function for which the state-space does not invalidate the sub-level constraint.
A visualization of the Lyapunov function associated with a straight motion
primitive can be found in~\cref{fig:visualized-lyapunov}.
\begin{figure}[!t]
  \centering
  \includegraphics[trim={3cm 7cm 3cm 7cm},
  scale=.6]{figures/rrtfunnel/straight-funnel-lyapunov-3d}
  \caption[The Lyapunov function visualized around a straight trajector]{A visualization of the Lyapunov function values around a straight
    motion primitive.}
  \label{fig:visualized-lyapunov}
\end{figure}

However, for the funnels in this thesis, the initial condition set will be given
by the hyper-ellipsoid
\begin{align}
  \mathcal{X}_0 &= \set{\vect{x} \in \R^{3} \mid \vect{x}^{T} Q \vect{x}} \\
  Q &= \begin{bmatrix}
    2 & 0 & 0 \\
    0 & 2 & 0 \\
    0 & 0 & 4
  \end{bmatrix},
\end{align}
which means that the funnel will have a diameter of one half in the xy-plane,
and the \(\theta\) inlet will be wider closer to the center of the funnel, which
is beneficial, as this is where most of the paths in the experiment setup is
expected to enter.


\subsection{Minimizing the Projected Volume of the Funnel}
\label{subsec:xy-cost-function}

In the \rrtfunnel{} algorithm, the size of the of the hyper-ellipsoid which
contains the reachable set is not equally important in all dimensions for all
planning problems. In the forest traversal case from the introduction, the size
of the ellipsoid in the \(\theta\) dimension is unimportant. There is no need in
minimizing the value of \(\theta\), as it will not make the traversal of the
forest any easier, in fact it might inflate the size of the \((x,y)\) ellipsoid.
As an example: For the dynamical model \eqref{eq:model-dynamics} the size of the
funnel projected down into the xy-plane will be the most important metric.
Whether or not the airplane's orientation parameter \(\theta\) is close to the
nominal heading is of less concern, and is therefore down-prioritized. Having a
large \(\theta\) semi-axis in the hyper-ellipsoid can also be beneficial, as it
increases the inlet of the ellipsoid, which is beneficial if the funnel is to be
composed with another funnel at some other point in the planning process.

For the cost function in the funnel generation \cref{alg:funnelalgorithm} on
page~\pageref{alg:funnelalgorithm}, which in general is a maximization of the
determinant of the upper bound ellipse for the funnel set, it is beneficial to
modify the cost function to penalize the size of the
xy-ellipsoid~\cite{majumdarRobustOnlineMotion2013}.

Therefore in order to minimize the actual size of the funnel where the physical
airplane can move in the world space, the cost function has to be modified. This
can be done through a projection map \(\pi \colon \R^n \rightarrow \R^{n_p}\),
which gives the ellipsoid of interest as \( \mathcal{E} = \set{\bar{\vect{x}}
  \in \R^n \mid \bar{\vect{x}}^TS_{k}\bar{\vect{x}} \leq 1} \mathEoS \) With the
projected ellipsoid given by \( \pi(\mathcal{E}) = \set{\bar{\vect{x}} \in \R^n
  \mid \bar{\vect{x}}^TS^{(p)}_{k}\bar{\vect{x}} \leq 1}, \) where \( S_k^{(p)}
= \p{PS_k^{-1}P^T}^{-1}, \) and \(P\) is an \(n\times n_p\) projection matrix.

Since minimizing the volume of the ellipsoid \(\pi(\mathcal{E})\) using
\acl{SDP} relies on maximizing the determinant of \(\matr{S}_k\), and \(\deter(
\matr{S}_k)\) is a nonlinear function of \(S_k\), the function has to be
linearized in order for it to be handled by the \ac{SOS} framework.
\citeauthor{majumdarFunnelLibrariesRealtime2017}~\cite{majumdarFunnelLibrariesRealtime2017}
solves this by linearizing \(\deter(\matr{S}_k)\) at the solution of
\(\matr{S}_k\) from the previous iteration, and maximizes this linearization
instead. In the end this translates to
\begin{IEEEeqnarray*}{ll}
  \lin \bigl( \deter \p{ \matr{S}_k} \bigr) &=  \IEEEyesnumber \\
  \IEEEeqnarraymulticol{2}{r}{\Tr \bigl( \matr{P}^{T}{\p{ \matr{P}
      \matr{S}_{k,0}^{-1} \matr{P}^T}}^{-1} \matr{P} {\matr{S}_{k,0}}^{-1}
    \matr{S}_k {\matr{S}_{k,0}}^{-1} \bigr)},
\end{IEEEeqnarray*} 
where \( \matr{S}_{k,0}\) is the nominal value for the linearization, and \(\Tr\)
is the trace of the matrix.

\subsection{Optimization of the Nominal \ac{LQR}-Controller}
\label{subsec:searching-for-a-controller}

With the non-optimal feedback controller given to the funnel calculation
framework (non-optimal with regards to the funnel calculation cost function),
the size of the funnels will in general be larger than if the optimizer is given
a better controller. Thus in order to further minimize the size of the funnel in
the xy-plane, this method, along with the cost function from
\cref{subsec:xy-cost-function} is used to make traversal through obstacles in
the world space easier, through minimizing the size of the reachable set. Hence,
the initial controller fed to the algorithm can be optimized with the goal of
minimizing the size of the funnel, given a few conditions on the
system~\cite[sec~4.3.2]{majumdarFunnelLibrariesRealtime2017}.

In order for the controller to be optimized, the system needs to be control
affine, i.e. it can be written on the form
\begin{equation}
  \dot{\vect{x}} = f(\vect{x}(t)) + g(\vect{x}(t)) \vect{u} (t),
\end{equation}
so that the control policy can be parameterized as a polynomial
\(\bar{\vect{u}}_f(t,\bar{\vect{x}})\), and the system dynamics written as
\begin{equation}
  \dot{\bar{\vect{x}}} = f(\vect{x}_0(t) + \bar{\vect{x}}(t)) + g(\vect{x}(t))\left( \vect{u}_0(t) + \bar{\vect{u}}_f(t,\bar{\vect{x}}) \right) - \bar{\vect{x}}_0 \mathEoS \label{eq:dynamics-control-affine}
\end{equation}
Given that the dynamical model in \cref{eq:model-dynamics} is control affine,
since
\begin{IEEEeqnarray*}{rl}
  \dot{\vect{x}} &= %
  f(\vect{x}(t)) + g(\vect{x}(t)) \vect{u} (t) \IEEEyesnumber \\
  &= %
  \begin{bmatrix}
    -v(t)\sin (\theta) \\
    v(t) \cos (\theta) \\
    0
  \end{bmatrix}
  +
  \begin{bmatrix}
    0 \\
    0 \\
    1 \\
  \end{bmatrix}
  \vect{u}(t),
\end{IEEEeqnarray*}
the feedback controller can be optimized by adding the coefficients of the
polynomial \(\vect{u}_f(t,\bar{\vect{x}})\) to the set of decision variables in
the original optimization problem~\eqref{opt:discrete}. The only issue is
that now \(\dot{V}\) is bilinear in the decision variables \(V\) and
\(\bar{\vect{u}}_f\), as well as the other bilinear decision variables from the
\cref{opt:time-dependent-optimization-problem}, as can be seen from
\begin{equation}
  {
    \dot{V}(t,\vect{x}) = \frac{\partial V(t,\vect{x})}{\partial \vect{x}} \dot{\bar{\vect{x}}} + \frac{\partial V(t,\vect{x})}{\partial t},
  }
\end{equation}
where \(\dot{\bar{\vect{x}}}\) is now given by
\cref{eq:dynamics-control-affine}. Thus in order to optimize the control input a
search is done in the variables \( (\bar{\vect{u}}_f,\rho,L_t,L_{0,i},S_k) \)
while keeping \( (V,L,L_{\epsilon,k}) \) fixed. This method combined with the
uncertainty added in~\cref{sec:adding-uncertainty}, is what forms the basis for
the funnel computations as robust motion primitives for traversal in a dense
forest environment, as summarized in \cref{alg:funnelalgorithm-extended}
(Optimization 2).

\begin{figure}[!t]
  \caption{Feedback Funnel computation} \label{alg:funnelalgorithm-extended}
  \begin{algorithmic}[0]
    \Procedure{Feedback Funnel Computation}{$a,b$}\Comment{Computes the feedback funnel}
    \State \(cost_{prev} = \infty\)
    \State converged = false
    \While{\( \neg converged\)}
    \State Optimization problem 1:
    \State %
    \begin{align*}
      \underset{\substack{\bar{u}_f,L,L_{t},L_{0,i},S_{k},L_{}}}{\inf}&  \sum_{k=1}^{N} \vol \bigl( \mathcal{E}(t_{k}) \bigr) & \\    
      \text{subject to } & V \text{ and } \rho \text{ constant.}& \\
    \end{align*}
    \State Optimization problem 2:
    \State %
    \begin{align*}
      \underset{\substack{\bar{u}}_f,\rho,L_{t},L_{0,i},S_{k}}{\inf}&  \sum_{k=1}^{N} \vol \bigl( \mathcal{E}(t_{k}) \bigr) & \\    
      \text{subject to } & (V,L,L_{\mathcal{E},k}) \text{ constant.}& \\
    \end{align*}
    \State Optimization problem 3:
    \State %
    \begin{align*}
      \underset{\substack{V,\rho, L_{t},L_{0,i},S_{k}}}{\inf}&  \sum_{k=1}^{N} \vol \bigl( \mathcal{E}(t_{k}) \bigr) & \\    
      \text{subject to } & (L,L_{\mathcal{E},k},\bar{u}_f) \text{ constant.}& \\
    \end{align*}
    \State cost = \(\sum_{k=1}^{N} \vol \bigl( \mathcal{E}(t_{k}) \bigr) \)
    \If{\(\frac{cost_{prev} - cost}{cost_{prev}} < \epsilon\)}
    \State converged = true
    \EndIf
    \State \(cost_{prev} = cost\)
    \EndWhile
    \EndProcedure
  \end{algorithmic}
\end{figure}

\subsection{Adding the Uncertainty Constraints}
\label{sec:adding-uncertainty}

The system dynamics and funnel generation theory presented this far has not been
able to handle system uncertainty, which is vital for the safe execution of the
\rrtfunnel{} algorithm. However, the basic formulations presented do have all
the necessary formulations present, and adding uncertainty is equivalent to
adding another constraint to the optimization problem in
\cref{eq:sufficient-conditions}.

Following are the changes to the formulation of the \ac{SOS} optimization
condition \cref{eq:funnelsufficient} so that a funnel takes into account a
bounded uncertainty term of the form \(\mathcal{W} = \set{ w(t) \in R^d \mid
  g_{w,j}(w) \geq 0\, \forall j =
  1,\ldots,N_w}\)~\cite{majumdarRobustOnlineMotion2013}. But first the
uncertainty has to be added to the system dynamics \cref{eq:model-dynamics}.
This is done through adding an uncertainty term \(w\) into
\eqref{eq:dynamicalsystem}, so that
\begin{equation}
  \dot{\bar{\vect{x}}} = f_{\mathit{cl}}(t, \bar{\vect{x}}(t), w(t)) \mathEoS
\end{equation}
Which in this paper is an additive uncertainty so that
\cref{eq:model-dynamics-cl} turns into
\begin{equation}
  \dot{\bar{\vect{x}}} = %
  \begin{bmatrix}
    -v(t)\sin(\theta) \\
    v(t)\cos(\theta) \\
    -K\vect{x} (t) \\
  \end{bmatrix}
  +
  \begin{bmatrix}
    w(t) \\
    0 \\
    0
  \end{bmatrix} \mathEoS
\end{equation}
Then the requirement~\eqref{eq:reachableset} is slightly modified so that
\begin{IEEEeqnarray*}{lr}
  \label{eq:uncertain-reachableset}
  \bar{\vect{x}}(0) \in \mathcal{X} \implies \bar{\vect{x}}(t) \in F(t), \IEEEyesnumber \\
  \IEEEeqnarraymulticol{2}{r}{\forall t \in
  [0,T], \, \forall w \colon [0,T] \rightarrow \mathcal{W}},
\end{IEEEeqnarray*} 
where \(F(t)\) is the new formulation for reachable set of the uncertain system.
Thus the sufficient condition in \cref{eq:funnelsufficient} turns into
\begin{IEEEeqnarray*}{rl}
  \label{eq:funneluncertain-sufficient}
  V(t,\bar{\vect{x}}) = \rho(t) \implies&
  \dot{V}(t,\bar{\vect{x}},w) < \dot{\rho}(t), \IEEEyesnumber \\
  &\forall t \in [0,T], \, \forall w(t) \in \mathcal{W} \mathEoS
\end{IEEEeqnarray*}
The Lyapunov function derivative then becomes
\begin{equation}
  \dot{V}(t,\bar{\vect{x}}, w) = \frac{\partial V(t,\bar{\vect{x}})}{\partial \vect{x}} f_{\mathit{cl}}(t,\bar{\vect{x}},w) + \frac{\partial V(t,\bar{\vect{x}})}{\partial t},
\end{equation}
and the optimization condition \cref{eq:sufficient-conditions} turns into
\begin{IEEEeqnarray*}{lr}
  \label{eq:optimizationconditionuncertain}
  \dot{\rho}(t) - \dot{V}(t,\bar{\vect{x}},w) - L(t,\bar{\vect{x}},w) & \IEEEyesnumber  \\
  \bigl( V(t,\bar{\vect{x}}) -\rho(t) \bigr) - L_{t}(t,\bar{\vect{x}},w) \bigl( t\left( T - t \right) \bigr)  & \nonumber \\
  - \sum_{j=1}^{N_{w}} L_{w,j}(t,\bar{\vect{x}},w)g_{w,j}(w) \quad \text{is SOS} & \\
  \left( L, L_t, L_{w,j} \right) (t,\bar{\vect{x}},w) \qquad \text{are SOS}, \; \forall j = 1,\ldots,N_w, \nonumber
\end{IEEEeqnarray*}
with the uncertainty constraints added.

A figure of a straight funnel motion primitive calculated with uncertainties by
the \ac{SOS} solver from the code in \cref{sec:sos-program-implementation} can
be seen in \cref{fig:funnel-calculation-visuals}.

\begin{figure}[!t]
  \centering \includegraphics[width=\linewidth, scale=.5, trim={0cm 6cm 0cm
    6cm}]{figures/method/funnel-calculation-visuals}
  \caption[A funnel calculated around a straight trajector]{A funnel calculated
    around a straight motion trajector. Shown is the value of \(\rho(t)\), and
    \(\sum \rho(t_k)\) as it is incrementally improved by the numerical solver.
    The bottom figures are the funnel projected down in the xy-plane. The left
    the ellipsoids are overlaid on top of each other, and on the right they are
    plotted on top of their respective sampling points in time \(t_k\).}
  \label{fig:funnel-calculation-visuals}
\end{figure}


\subsection{Funnel Transformations and Invariance}
\label{subsec:shifting-funnels}

Now that the funnels are able to be calculated for a basic set of motion
primitives, it is time to start looking at chaining these primitives together in
order to construct longer and more complex motions from a basis of motion
primitives. Thus, in order to freely shift funnels around in the configuration
space, the cyclic coordinates of the system have to be determined, so that the
dynamics of the system is never violated (see \cref{subsec:cyclic-coordinates}).
Even though the funnels can now start and end in a completely different part of
the configuration space, the original dynamics must not be violated. Therefore
the cyclic and non-cyclic coordinates of the system must be decided. This is
done through finding the cyclic and non-cyclic coordinates through the method
from \cref{subsec:cyclic-coordinates}. Therefore, given the modelfrom
\cref{eq:model-dynamics} the cyclic coordinates of the system are found from:
\begin{align*}
  \mathcal{L} &= T - V = \frac{1}{2} mv^2 + \frac{1}{2}I\dot{\theta}^2 \\ 
              &= \frac{1}{2} \left(  m \left(
                \dot{\vect{x}}^2 \sin^2 \theta + \dot{\vect{x}}^2 \cos^2 \theta
                \right)  + I {\dot{\theta}}^2 \right) \\
              &= \frac{1}{2} \left(  m\dot{\vect{x}}^2 + I {\dot{\theta}}^2 \right)
\end{align*}
which shows that the Lagrangian is invariant to shifts in the \((x,y,\theta)\)
variables, since \(\frac{\partial\mathcal{L}}{\partial q_i} = 0, \, q_i =
x,y,\theta\). Now any funnel in the base set can be shifted freely around in the
cyclic coordinates of the system without changing the solution to the system
dynamic equation, and thus create an infinite set of funnels in the state space
for the planner to work with. Through the partitioning of coordinates into
cyclic- and non-cyclic coordinates of the form \(\vect{x} = \left[ x_c\; x_{nc}
\right]^{T }\), the state dynamics \cref{eq:model-dynamics} only depends on the
cyclic coordinates of the system. Thus, a trajectory of the form \(t \rightarrow
\bigl( \vect{x}(t), \vect{u}(t) \bigr) \) which solves \(\dot{\vect{x}} = f
\bigl(\vect{x}(t), \vect{u}(t) \bigl) \) can then be transformed through a shift
\(\Psi_{c}\) along the cyclic coordinates of the system to yield a valid
solution of the form
\[
  t \rightarrow \bigl( \Psi_{x}(\vect{x}(t)), \vect{u}(t) \bigr)
\]
where the transform \(\Psi\) is given by
\[
  \Psi \bigl( \begin{bmatrix}
    \vect{x}_{c}  \\ \vect{x}_{\mathit{nc}} 
  \end{bmatrix}
  \bigr) =
  \begin{cases}
    \vect{x}_{c} \rightarrow \vect{x}^{'}_{c} \\
    \vect{x}_{\mathit{nc}} \rightarrow \vect{x}_{\mathit{nc}} \mathEoS
  \end{cases}
\]
However, since \( \dim (\vect{x}) = \dim(\vect{x}_{c}) \), for
the~\cref{eq:model-dynamics}, it is not necessary to handle the non-cyclic case.


\subsection{Sequential Funnel Composition}
\label{sec:composable-funnels}

Now that funnels can be shifted freely around the configuration space along the
cyclic coordinates of the system to create new motion primitives, it is time to
start chaining funnels together to create trees of funnels that span out into
the planning environment in order to create a robust motion plan.

However, in order for two funnels to create a third and new motion primitive
when chained together, they need to be composable. This means that the inlet of
the second funnel needs to be fully contained within the outlet of the first
one. Otherwise the robustness guarantees of the traversal will be lost. An
abstract pictorial representation of two funnels composed together can be seen
in~\cref{fig:two-funnels-composed} to emphasize this observation.

The mathematical definition of funnel composition
(\cref{def:funnel-composition}) that is used to verify that two funnels are
composable is not in accordance with the new transformed funnels from
\cref{subsec:shifting-funnels}. However, take note that the definition only has
to be modified slightly in order to take into account the translation along the
cyclic coordinates of the system.
\begin{definition}
  \label{def:invarant-funnel-composition}
  An ordered pair \((F_1,F_2)\) of funnels \(F_1 \colon [0,T_1] \rightarrow
  \mathcal{P}(\R^n)\) and \(F_2 \colon [0,T_2] \rightarrow \mathcal{P}(\R^n)\)
  is \textit{sequentially composable modulo invariance} if there exists a shift
  along cyclic coordinates such that \(F_{1}(T_1) \subset
  \Psi_{c}\bigl(F_2(0)\bigr) \).
\end{definition}
In layman's terms this means that if a funnel \(F_2\) can be shifted along
cyclic coordinates to stack up against the outlet of funnel \(F_2\) so that they
are composable in the sense of \cref{def:funnel-composition}, they are
composable modulo
invariance~\cite[definition~3,sec~5]{majumdarFunnelLibrariesRealtime2017}. Since
any funnel in the configuration space will be a set consisting of the funnel
from the basic set, along with a transformation along the cyclic coordinates of
the system, the set of all funnels, \(\hat{\mathcal{F}}\), in the configuration
space, is written \(\hat{\mathcal{F}} = \set{F_n \in \R^n \mid \Psi_{c,i}(F_i),
  F_i \in \mathcal{F}}\). Here \(\mathcal{F}\) is the basic set of funnels, and
since the transformation is already known the composability is straightforward
to compute.

\begin{figure}[!t]
  \centering {\includegraphics[width=.8\columnwidth]{figures/method/funnel-composition}}
  \caption[Two composable funnels]{Two funnels that can be successfully composed, as the outlet of the
    first one is fully contained in the inlet of the second.}
  \label{fig:two-funnels-composed}
\end{figure}

Therefore apply the generalized S-procedure on
\begin{equation}
  V_1(T_1,\bar{\vect{x}}) \leq \rho_1(T_1) \implies V_2(0, \bar{\vect{x}}) \leq \rho_2(0) \mathEoS
\end{equation}
Then the composability of two funnels can be checked through the \ac{SOS}
program
\begin{IEEEeqnarray*}{ll}
   \text{Find } L(\vect{x}) \IEEEyesnumber \\
  \text{s.t.} \\
   \IEEEeqnarraymulticol{2}{r}{\rho_2(0) - V_2(0,\vect{x}) - L(\vect{x})\left( \rho_1(T_1) - V_1(T_1,\vect{x}) \right) \text{ is SOS}} \\
  \IEEEeqnarraymulticol{2}{r}{L(\vect{x}) \text{ is SOS}} \mathEoS
\end{IEEEeqnarray*}
Which is implemented using \textsc{sostools}~\cite{sostools} and \matlab{}. For a picture of funnels composed
together into a tree have a look at \cref{fig:funnel-composition-tree}.
\begin{figure}[!t]
  \centering
  \includegraphics[scale=.4, trim={0cm 7cm 0cm
    7cm}]{figures/method/funnel-tree} \caption[A tree of funnels built by the
  \rrtfunnel{} algorithm]{A tree of funnels built by the \rrtfunnel{} algorithm,
    showing how longer motion primitives are built up from primitives in the
    basis set.}
  \label{fig:funnel-composition-tree}
\end{figure}


\subsection{Invariance of the Funnels Calculated}

The funnels generated are \textit{outer approximations} of reachable sets for
the system at hand~\cite{majumdarFunnelLibrariesRealtime2017}. This means that
in general they are larger than the actual reachable set for the system. This
can be verified through a Monte-Carlo simulation. Running N-simulations from the
funnel inlet, and storing the solutions, it is possible to visualize the actual
funnel for the system, an example of which can be seen in
\cref{fig:funnel-simulated-overlaid}, and further explored for a single funnel
in \cref{fig:outer-approximation-monte-carlo}.

By comparing one of the funnels in the funnel set with a funnel based from
\(10.000\) simulation runs, it is seen that the calculated funnels are indeed
proper outer approximations of the time-reachable sets for the uncertain
dynamical system. Therefore, the conclusion is that the uncertain trajectories
are contained within the funnels used in the planner, and the trajectories can
be seen as robust to uncertainty given the uncertainty and dynamical assumptions
made.

%% TODO -- Should this monster even be included?
% \begin{figure}[!t]
%   \begin{subfigure}[c]{0.3\linewidth}
%     \includegraphics[width=.95\linewidth, trim={0cm 4cm 0cm
%       4cm}]{figures/method/FunnelSimnew4}
%   \end{subfigure}
%   \begin{subfigure}[c]{0.3\linewidth}
%     \includegraphics[width=.95\linewidth, trim={0cm 4cm 0cm
%       4cm}]{figures/method/FunnelSimnew1}
%   \end{subfigure}
%   \begin{subfigure}[c]{0.3\linewidth}
%     \includegraphics[width=.95\linewidth, trim={0cm 4cm 0cm
%       4cm}]{figures/method/FunnelSimnew5}
%   \end{subfigure}
%   \caption[A visualization of the simulated and the calculated reachable set]{The simulated non-polynomial system trajectories (green), overlaid
%     with the outer approximation that is the funnel returned by the \ac{SOS}
%     calculation (grey) for three trajectories from the trajectory library
%     \(\mathcal{T}\).}
%   \label{fig:funnel-simulated-overlaid}
% \end{figure}

% \begin{figure}[!t]
%   % Regular xy-funnel
%   \begin{subfigure}{0.5\linewidth}
%     \includegraphics[trim={0cm 6cm 0cm 6cm},
%     width=.95\linewidth]{figures/method/FunnelSim1}
%     \caption{Comparison of the \ac{SOS} funnel in the xy-plane with the
%       simulated non-polynomial system overlaid in green, generated from
%       \(10.000\) Monte-Carlo simulations.}
%   \end{subfigure}%
%   % 
%   \quad
%   %
%   \begin{subfigure}{0.5\linewidth}
%     % y-theta funnel
%     \includegraphics[trim={0cm 6cm 0cm 6cm},
%     width=.95\linewidth]{figures/method/FunnelSimythetafunnel}
%     \caption{Comparison of the \ac{SOS} funnel in the \(\theta\)-y plane, with
%       the simulated non-polynomial system overlaid in green, generated from
%       \(10.000\) Monte-Carlo simulations.}
%   \end{subfigure}%
%   % 
%   \\
%   %
%   \fbox{%
%     \begin{subfigure}{0.5\linewidth} % Left subfig
%       % 
%       \begin{subfigure}[b]{0.5\linewidth} % Inner left
%         \includegraphics[trim={1cm 7cm 1cm 7cm},
%         width=\linewidth]{figures/method/FunnelSimOverlaid1funnel-1}
%       \end{subfigure}%
%       % 
%       \begin{subfigure}[b]{0.5\linewidth}
%         \includegraphics[trim={1cm 7cm 1cm 7cm},
%         width=\linewidth]{figures/method/FunnelSimOverlaid3funnel-1}
%       \end{subfigure}%
%       % 
%       \\
%       % 
%       \begin{subfigure}[b]{0.5\linewidth}
%         \includegraphics[trim={1cm 7cm 1cm 7cm},
%         width=\linewidth]{figures/method/FunnelSimOverlaid6funnel-1}
%       \end{subfigure}%
%       % 
%       \begin{subfigure}[b]{0.5\linewidth}
%         \includegraphics[trim={1cm 7cm 1cm 7cm},
%         width=\linewidth]{figures/method/FunnelSimOverlaid9funnel-1}
%       \end{subfigure}%
%       % 
%       \\
%       % 
%       \begin{subfigure}[b]{0.5\linewidth}
%         \includegraphics[trim={1cm 7cm 1cm 7cm},
%         width=\linewidth]{figures/method/FunnelSimOverlaid12funnel-1}
%       \end{subfigure}%
%       % 
%       \begin{subfigure}[b]{0.5\linewidth}
%         \includegraphics[trim={1cm 7cm 1cm 7cm},
%         width=\linewidth]{figures/method/FunnelSimOverlaid15funnel-1}
%       \end{subfigure}%
%       % 
%       \\
%       % 
%       \begin{subfigure}[b]{0.5\linewidth}
%         \includegraphics[trim={1cm 7cm 1cm 7cm},
%         width=\linewidth]{figures/method/FunnelSimOverlaid18funnel-1}
%       \end{subfigure}%
%       % 
%       \begin{subfigure}[b]{0.5\linewidth}
%         \includegraphics[trim={1cm 7cm 1cm 7cm},
%         width=\linewidth]{figures/method/FunnelSimOverlaid20funnel-1}
%       \end{subfigure}%
%     \end{subfigure} % End Left subfig
%   }
%   % 
%   % \; % Left and right split
%   % 
%   \fbox{%
%     \begin{subfigure}{0.5\linewidth} % Right subfig
%       % 
%       \begin{subfigure}[b]{0.5\linewidth} % Inner left
%         \includegraphics[trim={1cm 7cm 1cm 7cm},
%         width=\linewidth]{figures/method/FunnelSimOverlaid1funnel-1y-theta}
%       \end{subfigure}%
%       % 
%       \begin{subfigure}[b]{0.5\linewidth}
%         \includegraphics[trim={1cm 7cm 1cm 7cm},
%         width=\linewidth]{figures/method/FunnelSimOverlaid3funnel-1y-theta}
%       \end{subfigure}%
%       % 
%       \\
%       % 
%       \begin{subfigure}[b]{0.5\linewidth}
%         \includegraphics[trim={1cm 7cm 1cm 7cm},
%         width=\linewidth]{figures/method/FunnelSimOverlaid6funnel-1y-theta}
%       \end{subfigure}%
%       % 
%       \begin{subfigure}[b]{0.5\linewidth}
%         \includegraphics[trim={1cm 7cm 1cm 7cm},
%         width=\linewidth]{figures/method/FunnelSimOverlaid9funnel-1y-theta}
%       \end{subfigure}%
%       % 
%       \\
%       % 
%       \begin{subfigure}[b]{0.5\linewidth}
%         \includegraphics[trim={1cm 7cm 1cm 7cm},
%         width=\linewidth]{figures/method/FunnelSimOverlaid12funnel-1y-theta}
%       \end{subfigure}%
%       % 
%       \begin{subfigure}[b]{0.5\linewidth}
%         \includegraphics[trim={1cm 7cm 1cm 7cm},
%         width=\linewidth]{figures/method/FunnelSimOverlaid15funnel-1y-theta}
%       \end{subfigure}%
%       % 
%       \\
%       % 
%       \begin{subfigure}[b]{0.5\linewidth}
%         \includegraphics[trim={1cm 7cm 1cm 7cm},
%         width=\linewidth]{figures/method/FunnelSimOverlaid18funnel-1y-theta}
%       \end{subfigure}%
%       % 
%       \begin{subfigure}[b]{0.5\linewidth}
%         \includegraphics[trim={1cm 7cm 1cm 7cm},
%         width=\linewidth]{figures/method/FunnelSimOverlaid20funnel-1y-theta}
%       \end{subfigure}%
%     \end{subfigure}%
%   }
%   \caption[The calculated funnel overlaid the results of a Monte-Carlo simulation]{The figures on the left show that the funnel approximation is a lot
%     tighter to the 'real' funnel in the x-y plane, than it is in the \(\theta\)
%     domain, which is to be expected, considering the cost function given to the
%     procedure.}
%   \label{fig:outer-approximation-monte-carlo}
% \end{figure}


\section{RRT}
\label{sec:RRT}

With the basic framework for dealing with funnels as motion primitives
constructed, it is time to build the \ac{RRT} part of the \rrtfunnel{}
algorithm. The reason for basing the global path planning framework on the
\ac{RRT} motion planning algorithm are as follows. One, it has the ability to
quickly expand deep into the search-space, and then later progress towards a
finer sampling, which is valuable as it avoids local minima. Two, the \ac{RRT}
algorithm is easily extensible to larger state spaces, and thus adding to the
generality of the \rrtfunnel{} algorithm, such that it can be adapted to fit a
wide range of dynamical systems, while at the same time it has only three main
components that needs to be in place in order for successful path planning to
happen in an arbitrary configuration space. Namely, a suitable probability
distribution to sample from, and a distance metric for the nearest neighbor and
the extension step. The \ac{RRT} algorithm is beneficial as most of the
complexity accompanied with the planning problem (like uncertainty and
controller calculations) has already been handled by the \ac{SOS} framework, and
hence the \ac{RRT} algorithm need only concern itself with stacking one robust
motion primitive after the other without any concern for the complexities
mentioned above.

\subsection{Uniform Sampling in \(SE(2)\)}

The \ac{RRT} algorithm needs uniform sampling of the state space in order for it
to operate optimally, as over- or under-sampling certain parts of the state
space can lead to poor performance. Therefore one needs to be careful when
sampling from a configuration space with non Euclidean topology, as the sampling
is not necessarily uniform~\cite{kuffnerEffectiveSamplingDistance2004}.

If sampling from a configuration space which is formed strictly from Cartesian
products of the form \(X = X_1\times X_2\times \cdots \times X_n\), and each
Cartesian space is sampled uniformly, then the product will also be uniformly
sampled. One needs to be more careful when dealing with rotations however, as
the probability density measure can become non-uniform~\cite{Lav06}. Take the
polar coordinates as an example. Sampling uniformly from \(r\) and \(\theta\)
does not form a uniform sample product, as the probability distribution function
will have a higher probability density away from the origin, as the outer
circles will contain a bigger area. For the model~\cref{eq:model-dynamics} which
moves in \(x,y,\theta\) the samples can be generated uniformly on the
topological cylinder through: \( (x,y,\theta) = (\mathnormal{X}, \mathnormal{Y},
\mathnormal{\Theta}) \) where \((\mathnormal{X}, \mathnormal{Y},
\mathnormal{\Theta})\) are a random variables in the interval
\([0,1)\)~\cite{kuffnerEffectiveSamplingDistance2004}. The \(\mathnormal{X}\)
and \(\mathnormal{Y}\) variables can simply be scaled by the range of the world
space, but also the \(\mathnormal{\Theta}\) can be scaled appropriately since
for \(SO(2)\), if the rotations are parameterized on \([0,1]\setminus\sim\)
(where \(\setminus\sim\) means that 0 and 1 are the same), then the stochastic
variable can be multiplied by a fixed constant, such as \(2\pi\). This means
that the sampling will be uniform in the configuration space of the robot, as
long as the sampling space consists of a simple Cartesian product of uniform
random variables, which the sampling space for \cref{eq:model-dynamics}
is~\cite{Lav06}.


\subsection{Distance in Configuration Space}

Introducing a function which measures distance between two points in
configuration space introduces a metric space on the underlying configuration
space \((\modelconfigurationspace{},\rho)\), where \(\rho\) is a distance
function. Finding a good distance function for the metric space at hand is a
hard problem. In general the ideal metric function is the actual
\textit{cost-to-go} function for the system at hand. However calculating the
actual cost-to-go is equivalent to solving the original motion planning problem
anew, and is hence not viable~\cite{pengchengReducingMetricSensitivity2001}.

So, in order for the \rrtfunnel{} algorithm to efficiently explore the state
space it must have a good measure of distance between different poses in space,
without actually solving the planning problem anew. For a problem in the
Cartesian plane it is common to use the Euclidean distance. However, this is not
a good distance metric for non-holonomic systems, as it does not incorporate the
constraints of the system function, and has little bearing on the actual
cost-to-go of the system~\cite{parkFeedbackMotionPlanning2015}. In fact, for
sampling based planners such as the \ac{RRT}, the configuration space is only
sufficiently explored in the case where the distance function reflects the true
cost-to-go function~\cite{pengchengReducingMetricSensitivity2001}. Hence, all
other metrics will be a compromise of complexity and time vs efficiency.

Normally the \ac{RRT} algorithm splits the extension part into two parts. One
for identifying the closest node in the tree, and a second for the closest
extension that can be added onto the tree itself. Here a different distance
metric can be employed in each step. To reflect on the difficulty of creating a
general distance metric function have a look at the unicycle model
from~\cref{eq:model-dynamics}. From inspection it is seen that the model is not
able to instantaneously move in a direction orthogonal to the direction of
travel, as is seen in \cref{fig:non-holonomic-vehicle-euclidean-weakness}. Here
the distance between two points might be small in the sense of a regular
Euclidean distance metric, but due to the differential constraints on the system
model, the model has to move far in order to reach the configuration sought.

The \rrtfunnel{} algorithm will use the same metric for both the closest node
and the extend operation on the funnel graph. The metric chosen is a modified
Euclidean metric which weights the angle \(\theta\) depending on how close the
airplane is to the final configuration, and is defined as
\[
  \rho(\vect{x}_{1}, \vect{x}_{2}) = w_{1}\norm{\mathnormal{X_{1}} -
    \mathnormal{X_{2}}} + w_{2}f(\theta_1,\theta_2) ,
\]
where \(\norm{\mathnormal{X_{1}} - \mathnormal{X_{2}}}\) is the standard
Euclidean metric, \(f\) is a function giving the distance between
headings~\cite{kuffnerEffectiveSamplingDistance2004}. The rotations and distance
is then scaled relative to the translation distance. Which helps solve some of
the problems with the Euclidean distance metric.

\begin{figure}[!t]
  \centering
  \includegraphics[scale=.2,angle=-90]{figures/rrtfunnel/non-holonomic-vehicle-euclidean-weakness}
  \caption[Distance metrics for non-holonomic vehicles]{Consider two poses
    \(p_0\) and \(p_1\). Although \(p_1\) is nearer the robot in Euclidean
    distance it is harder to get to due to differential constraints
    \textcite{parkFeedbackMotionPlanning2015}.}
  \label{fig:non-holonomic-vehicle-euclidean-weakness}
\end{figure}


\subsection{The Funnel-Graph}

Even though the \rrtfunnel{} algorithm can work just fine with a collection of
funnels, and simply brute-force all funnels at the planning stage, it is helpful
to associate some kind of structure with the collection. Therefore the funnels
will be organized into a graph structure \(\mathcal{G}\) where each funnel is an
edge in the graph, and the inlets and the outlets are vertices. The planner
needs information about which funnels that are composable, as they may not all
be composable with each other, implying that the resultant graph is not
necessarily complete.

\begin{figure}[!t]
  \begin{minipage}[c]{.45\columnwidth}
    \includegraphics[trim={5cm 5cm 5cm 5cm},
    width=.9\columnwidth]{figures/method/trajectory-sampled}
    \caption{Trajectory sampled 21 times.}
  \end{minipage} \; %
  \begin{minipage}[c]{.45\columnwidth}
    \includegraphics[trim={5cm 5cm 5cm 5cm},
    width=.9\columnwidth]{figures/method/funnel-sampled}
    \caption{The verified trajectory ellipsis overlaid at the sample times.}
  \end{minipage}
    \label{fig:funnel-straight-sampled}
\end{figure}

Composition of funnels is verified using \cref{def:invarant-funnel-composition},
and the composability graph is built using \cref{alg:create-funnel-graph} on
page~\pageref{alg:create-funnel-graph}. A \ac{SOS}-program which implements the
composition algorithm can be found in
\cref{sec:funnel-composability-program-sos}.

\begin{figure}[!t]
  \caption{Check funnel composability}
  \label{alg:create-funnel-graph}
  \begin{algorithmic}[0]
    \Procedure{CheckFunnelComposability}{\(\mathcal{F} \rightarrow
      \mathcal{G}(\mathcal{F})\)} \Comment{Takes \(\mathcal{F}\), the basic set
      of funnels, and returns \(\mathcal{G}\), a directed graph, representing
      the composability of the funnels.}
    \For{ \(F_{i} \in \mathcal{F}\)}
    \For {\(F_{j} \in \mathcal{F}\)}
    \If {\(F_{i(t_{0})} \subset F_{j}(t_{\mathit{end}})\)}
      \State \(\mathcal{G} \leftarrow{} \left( F_{i}(t_{0}), F_{j}(t_{end})
      \right)\)
    \EndIf
    \EndFor
    \EndFor
    \EndProcedure
  \end{algorithmic}
\end{figure}


\subsubsection{Emergency Maneuver}

If the airplane is to leave the verified funnel at execution time -- this could
happen for any number of reasons, such as unmodeled uncertainties -- the plane
should execute the emergency maneuver, which in this case is a loiter loop. In
general an emergency maneuver can be any sort of 'safe' maneuver for the model
at hand -- such as a sudden stop for a vehicle, or idling in one place for a
quad-copter. This will then be the last motion primitive that the planner
executes, and the planner will come to a halt, as the robustness guarantees have
been lost.


\subsection{Collision Detection}

Collision detection is done creating a convex hull incorporating all the
ellipsis projected down into the xy-plane, and is what can be seen as the grey
area in \cref{fig:funnel-straight-sampled}. Then, with \matlab's polynomial
toolbox, collision detection is made through the \textit{intersect} function for
polynomials, as the obstacles are also represented as polynomials.


\subsection{The \rrtfunnel{} Algorithm}

With the basic framework finished, it is time to introduce the formulation of
the \rrtfunnel{} algorithm itself. The \rrtfunnel{} algorithm is a modified
\ac{RRT} algorithm which employs the precomputed funnels as motion primitives
for its expansion operator, and pseudocode for its definition can be found in
\cref{alg:rrtfunnel} on page~\pageref{alg:rrtfunnel}.

\begin{figure}[!t]
  \caption{\rrtfunnel{} algorithm}
  \label{alg:rrtfunnel}
  \begin{algorithmic}[0]
    \Procedure{rrtfunnel}{}
    \State input: \(q_{0}\)
    \State output: RRT-Funnel-Graph \(\mathcal{G}\)
    \State
    \State Offline Phase: Generate the Funnels
    \State
    \State Online Phase:
    \State TestUncertainFunnels()
    \State BuildComposabilityMatrix()
    \State \(\mathcal{G}.\mathnormal{init}(q_{0})\)
    \For {\(i \leftarrow 1\) to \(k\)}
    \State \(q_{\mathnormal{rand}} \leftarrow \) SampleRandomConfiguration()
    \State \(q_{\mathnormal{near}} \leftarrow\) FindNearestVertex(\(q_{\mathnormal{rand}}, \mathcal{G}\))
    \State \(q_{\mathnormal{new}} \leftarrow\)  Extend(\(q_{\mathnormal{near}}, q_{\mathnormal{rand}}\))
    \If{\(q_{\mathnormal{new}} \in \modelconfigurationspacefree{}\)}
    \State \(\mathcal{G}\).addVertex(\(q_{\mathnormal{new}}\))
    \State \(\mathcal{G}\).addEdge(\(q_{\mathnormal{near}},q_{\mathnormal{new}}\))
    \If {\(q_{\mathnormal{new}} \in \mathcal{X}_{\mathnormal{goal}} \)}
    \State \textbf{return} ExtractBranch(\(\mathcal{G}\))
    \EndIf
    \EndIf
    \EndFor
    \EndProcedure
  \end{algorithmic} 
\end{figure}

\subsection{Expanding the Size of the Funnels}

In general the funnels generated are computed for the point model in
\cref{eq:dynamicalsystem} only, and hence, in order to run the experiment with a
model of some size, the funnels have to be expanded by the largest radius of the
given model. As the funnels are ellipsis surrounding the point at the trajectory
that they verify, the funnels can be expanded by any radius by a linear
transformation (like to the unit circle, expand by the wanted radii, and then
transform back), as can be seen in \cref{fig:expanded-funnel}.


\begin{figure}[!t]
  \centering \includegraphics[scale=.5]{figures/method/expanded-funnel}
  \caption[The expanded experiment funnel]{The original funnel created from the point model, with a funnel
    expanded by a radius of 0.1 surrounding it.}
  \label{fig:expanded-funnel}
\end{figure}

\subsection{Distance Metric}

For a non-holonomic system, like \cref{eq:model-dynamics}, the regular Euclidean
distance metric is a poor approximation ot the true cost-to-go of the system
(see \cref{fig:non-holonomic-vehicle-euclidean-weakness}). In general the
distance function is supposed to reflect the true cost-to-go of the system.
However, in general, calculating the true cost-to-go would result in solving the
planning problem anew, and hence is not
viable~\cite{pengchengReducingMetricSensitivity2001}.

The \rrtfunnel{} algorithm will use the same metric for both the closest node
and the extend operation on the funnel graph. The metric chosen is a modified
Euclidean metric which weights the angle \(\theta\) depending on how close the
airplane is to the final configuration, and is defined as
\[
  \rho(\vect{x}_{1}, \vect{x}_{2}) = w_{1}\norm{\mathnormal{X_{1}} -
    \mathnormal{X_{2}}} + w_{2}f(\theta_1,\theta_2) ,
\]
where \(\norm{\mathnormal{X_{1}} - \mathnormal{X_{2}}}\) is the standard
Euclidean metric, \(f\) is a function giving the distance between
headings~\cite{kuffnerEffectiveSamplingDistance2004}. The rotations and distance
is then scaled relative to the translation distance. Which helps solve some of
the problems with the Euclidean distance metric.

\subsection{Funnel Composition}
\label{subsec:funnel-no-composable}

In accordance with \cref{sec:composable-funnels}, the funnel robustness
guarantees are only valid if the funnels are composable as per
\cref{def:invarant-funnel-composition}. Unfortunately, the funnels do not
compose as per this definition in the experiments run, and the composition
testing of the algorithm has to be left out. Thus the experiments are run with a
funnel graph that is complete, and all funnels can compose with each other, at
the cost of the mathematical robustness guarantees of the system. This is
because the controller has no influence on the speed of the airplane, and hence
there is no way to make the system converge in the direction of speed as
exemplified in the~\cref{fig:funnel-conv}. This is further exemplified in
\cref{fig:funnel-inlet-outlet}, where the inlet is overlaid the outlets for the
projected xy-funnel.

\begin{figure}[!t]
  \centering
  \begin{minipage}{0.5\columnwidth}
    \includegraphics[width=.8\linewidth]{figures/experiments/sos-calculation}
  \end{minipage}%
  \begin{minipage}{0.5\columnwidth}
    \includegraphics[width=.8\linewidth]{figures/experiments/sos-calculation-inlet-outlet}
  \end{minipage}
  \caption[A slice of the inlet and the outlet ellipsis]{A slice of the inlet and the outlet ellipsis in the x-y and
    x-theta dimensions.}
  \label{fig:funnel-conv}
\end{figure}

\begin{figure}[!t]
  \centering
  \includegraphics[width=.8\columnwidth]{figures/experiments/funnel-inlet-outlet}
  \caption[The projection of the funnel inlet and outlet in the xy-plane]{The projection of the funnel inlet and outlet in the xy-plane. It is
    seen that the controller is able to make the funnel converge in the
    x-direction as expected, however, it has no control in the y-direction, as
    there is no controller steering the speed of the vehicle.}
  \label{fig:funnel-inlet-outlet}
\end{figure}

Since the dynamical system has only one

as can be seen in \cref{fig:lyapunov-values}

\begin{figure}[!t]
  \centering
  \includegraphics[width=.8\columnwidth]{figures/experiments/lyapunov-values-simulation-run}
  \caption[A plot of the Lyapunov values for an experiment]{The plot of the Lyapunov values for a simulation run at the sampling
    times \(t_k\).}
  \label{fig:lyapunov-values}
\end{figure}

as can be seen in \cref{fig:airplane-in-funnel}

\begin{figure}[!t]
  \centering
  \includegraphics[width=.8\columnwidth]{figures/experiments/airplane-in-funnel} \caption[A
  figure of the airplane in the funnel]{A figure of the airplane in the funnel
  projected down on the xy-plane during a simulation run.}
\label{fig:airplane-in-funnel}
\end{figure}

\subsection{Experiment Setup}

The algorithm will be tested by generating a random strip of forest of depth
\(25m\), and then letting it, along with the benchmark algorithm find a way
through the environment to the other side, whilst being the subject of a
simulated crosswind (the uncertainty) of \((0,3,6) m/s\). The trees are circles
with a radius of \(0.2m\), and are placed randomly along the strip \(O=\left{
    \vect{x} \mid -50 \le x_{1} \le 50 \text{ and } 5 \le x_{2} \le 25
  \right}\), as the realization of a \textit{Poisson} process with density
\(\lambda = 0.2\) on this set. For each trial run, a new forest is generated in
this random fashion, and the algorithms are given the task to traverse the
generated map, see~\cite{Kroese_2014} for an introduction to Poisson processes.

The funnels for the \rrtfunnel{} algorithm are in this case made to handle
uncertainties up to and including \(3m/s\) in the x-direction of the airplane,
but does not currently have any control over the y-direcction (the speed). A
figure of the test environment can be seen in \cref{fig:simulated-forest}. The
\rrtfunnel{} algorithm is run with a goal bias of \(5\%\), in order to guide the
exploration of the state-space towards the other end of the planning map. Also,
a maximum of \(5000\) nodes is set as an upper treshold on both of the
algorithm's exploration trees.

The model in the experiments are imagined as being a plane, with the dimensions
shown in \cref{fig:radio-vehicle}, and the basis of trajectories employed can be
seen in \cref{fig:intial-trajectories-exp}.

\begin{figure}[!t]
  \centering
  \includegraphics[width=.8\columnwidth]{figures/experiments/radio-vehicle-model}
  \caption[The experiment airplane model]{The airplane employed in the simulation experiments.}
  \label{fig:radio-vehicle}
\end{figure}

\begin{figure}[!t]
  \centering
  \includegraphics[width=.8\columnwidth]{figures/experiments/initial-trajectories}
  \caption[The experiment trajectory set]{The initial trajectories used in the
    \rrtfunnel{} algorithm.}
  \label{fig:intial-trajectories-exp}
\end{figure}

\begin{figure}[!t]
  \centering
  \includegraphics[width=.8\columnwidth]{figures/experiments/simulated-forest}
  \caption{The experiment environment.}
  \label{fig:simulated-forest}
\end{figure}

\subsection{Quality of the Funnels Calculated (Approximated)}

The funnels generated are \textit{outer approximations} of reachable sets for
the system at hand~\cite{majumdarFunnelLibrariesRealtime2017}. This means that
in general they are larger than the actual reachable set for the system. This
can be verified through a Monte-Carlo simulation. Running N-simulations from the
funnel inlet, and storing the solutions, it is possible to visualize the actual
funnel for the system, an example of which can be seen in
\cref{fig:funnel-simulated-overlaid}, and further explored for a single funnel
in \cref{fig:outer-approximation-monte-carlo}.

By comparing one of the funnels in the funnel set with a funnel based from
\(10.000\) simulation runs, it is seen that the calculated funnels are indeed
proper outer approximations of the time-reachable sets for the uncertain
dynamical system. Therefore, the conclusion is that the uncertain trajectories
are contained within the funnels used in the planner, and the trajectories can
be seen as robust to uncertainty given the uncertainty and dynamical assumptions
made.

\begin{figure}[!t]
  \begin{minipage}[r]{0.3\columnwidth}
    \includegraphics[width=1\columnwidth, trim={0cm 6cm 0cm
      6cm}]{figures/method/FunnelSimnew4}
  \end{minipage}
  \begin{minipage}[c]{0.3\columnwidth}
    \includegraphics[width=1\columnwidth, trim={0cm 6cm 0cm
      6cm}]{figures/method/FunnelSimnew1}
  \end{minipage}
  \begin{minipage}[l]{0.3\columnwidth}
    \includegraphics[width=1\columnwidth, trim={0cm 6cm 0cm
      6cm}]{figures/method/FunnelSimnew5}
  \end{minipage}
  \caption[A visualization of the simulated and the calculated reachable set]{The simulated non-polynomial system trajectories (green), overlaid
    with the outer approximation that is the funnel returned by the \ac{SOS}
    calculation (grey) for three trajectories from the trajectory library
    \(\mathcal{T}\).}
  \label{fig:funnel-simulated-overlaid}
\end{figure}
